David Storey
CS4760 Project 6
May 9, 2019
My memory manager spawns up to 18 child processes which then make memory requests until they terminate.  To do this, they utilize a memory queue and request logical memory locations, which the parent translates into a page and checks against its frame table.  If the page is in the frame table, it grants the request and allows the child to continue.  If it is not in memory, it generates a page fault and looks for the least recently used frame (or the first frame with a 0 in the reference value), which it swaps out, then messages the child to continue, with the clock being incremented by a small value to indicate the additional time the process would take.  The frame table contains which process and page each entry contains, as well as its reference value and dirty bit, depending on whether the most recent access was a read or a write.  The parent will continue until all children have terminated, ctrl-c is pressed, 2 seconds have elapsed, or the log file contains 10 million characters.  If it exits by means other than all children terminating, it will print a message to the screen and kill any remaining children using SIGINT, then a small delay, then SIGKILL if the child is still running.  The children will catch a SIGINT signal to allow detaching from the shared memory.
